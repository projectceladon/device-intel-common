# prevent re-entrency (metatargets are calling them selves, e.g COPY_HEADERS)
ifeq ($(_metatarget),)
# get the name of the metatarget (which is the name of our symlink)
# it has to be very first place, because include will alter the MAKEFILE_LIST)
_metatarget := $(basename $(notdir $(call original-metatarget)))
_need_prebuilts :=
$(foreach project, $(_prebuilt_projects),\
  $(if $(findstring $(project)/, $(LOCAL_MODULE_MAKEFILE)),\
    $(eval _need_prebuilts := true)))

# Do not release prebuilts for tests modules
ifneq (,$(filter $(LOCAL_MODULE_TAGS), tests))
_need_prebuilts :=
endif

########################################################################################
ifneq (custom_external, $(_metatarget))
include $(call original-metatarget)
endif

########################################################################################

# do nothing more if we don't need prebuilts
ifneq (,$(_need_prebuilts))

# Record if this is a host module, to split host and target files in 2 different folders
# because a host and a target module can have same module name
ifeq ($(LOCAL_IS_HOST_MODULE), true)
    module_type :=  host
else
    module_type :=  target
endif

# transform the name of output dir,
# e.g. [/android_tree/]vendor/intel/PRIVATE/ipp -> vendor/intel/prebuilts/blackbay/ipp
# src makefile is renamed Android.mk in prebuilts out directory
_prj_path := $(dir $(patsubst $(PWD)/%,%,$(LOCAL_MODULE_MAKEFILE)))
LOCAL_MODULE_PREBUILT_MAKEFILE := $(PRODUCT_OUT)/$(call intel-prebuilts-path,$(_prj_path))Android.mk
# local shortcut
my := $(LOCAL_MODULE_PREBUILT_MAKEFILE)

# we only define the commands once, even LOCAL_MODULE_PREBUILT_MAKEFILE may be defined
# via several metatargets (because the original Android.mk builds several things)

ifeq (,$($(LOCAL_MODULE_PREBUILT_MAKEFILE).ORIG_MAKEFILE))
$(LOCAL_MODULE_PREBUILT_MAKEFILE).ORIG_MAKEFILE := $(LOCAL_MODULE_MAKEFILE)
$(LOCAL_MODULE_PREBUILT_MAKEFILE).REF_PRODUCT_NAME := $(REF_PRODUCT_NAME)

# We only make one target to build the makefile (the ACPs are done in this target)
$(LOCAL_MODULE_PREBUILT_MAKEFILE): $(ACP) $(EXTERNAL_BUILD_SYSTEM)/generic_rules.mk
# cannot use $(LOCAL_MODULE_PREBUILT_MAKEFILE) or $(my) inside the rules, as they are expanded at rule running time
# while those two variables, are overriden at makefile parsing time
# we rebuild the whole directory every time to make sure there is no remaining files from previous build
# We don't remove the whole directory but only the files at first level, else we might have conflicts between
# cascaded Android.mk, when building with -j x option
	@echo "Generate prebuilt makefile: $@"
	@mkdir -p $(dir $@)
	@find $(dir $@) -maxdepth 1 -type f -exec rm -f {} +
	@$(if $($@.copyfiles),\
		$(call copy-several-files, $($@.copyfiles)),)
	@echo '# autogenerated Android.mk' > $@
	@echo 'ifeq ($($@.REF_PRODUCT_NAME),$$(wildcard $($@.ORIG_MAKEFILE))$$(REF_PRODUCT_NAME))# test inexistance of original makefile, and correct ref product' >> $@
	@echo 'LOCAL_PATH := $$(call my-dir)' >> $@
	@$(foreach key, $($@.key_list), \
		$(call external-auto-prebuilt-boilerplate,$(key)) \
	)
	@$(foreach to, $($@.headers_to), \
		$(if $(filter _none_,$(to)), \
			$(eval _to_:=),\
			$(eval _to_:=$(to))) \
		$(if $(strip $($@.headers.$(to))), \
			$(call external-echo-makefile, '') \
			$(call external-echo-makefile, 'include $$(CLEAR_VARS)') \
			$(call external-echo-makefile, 'LOCAL_COPY_HEADERS:=$(strip $($@.headers.$(to)))') \
			$(call external-echo-makefile, 'LOCAL_COPY_HEADERS_TO:=$(strip $(_to_))') \
			$(call external-echo-makefile, 'include $$(BUILD_COPY_HEADERS)')))
	@$(foreach mk, $($@.extramakefile), \
		$(call external-echo-makefile, '') \
		cat $(mk) >> $@;)
	@$(foreach module, $($@.phony), \
		$(call external-phony-package-boilerplate, \
			$(module), \
			$($@.phony.$(module).LOCAL_REQUIRED_MODULES)))
	@echo 'endif' >> $@
endif

gathered :=


# Android build system defines primary arch and secondary arch.
#
# While 32bit primary/64bit secondary (aka 32p) could be supported, the build system
# currently doesn't leave room for this option.
# If secondary arch is supported, it is always 32bit while primary is 64bit
# as in build/core/envsetup.mk:
#     TARGET_2ND_ARCH_MODULE_SUFFIX := $(HOST_2ND_ARCH_MODULE_SUFFIX)
#     $(TARGET_2ND_ARCH_VAR_PREFIX)TARGET_OUT_SHARED_LIBRARIES := $(TARGET_OUT)/lib
#
# When multiple arch is supported, TARGET_2ND_ARCH is set.
#
# When target / host primary arch is 64bit, TARGET_IS_64_BIT / HOST_IS_64_BIT is true.

#### host native ####
handle_host_native :=

# Binaries from sources - do not just check on CLASS as for example, an executable could use any class
ifneq (,$(filter host_executable host_shared_library host_static_library, $(_metatarget)))
handle_host_native := true
endif
# Binaries from prebuilt
ifneq (,$(filter prebuilt, $(_metatarget)))
  ifneq (,$(filter STATIC_LIBRARIES SHARED_LIBRARIES EXECUTABLES, $(LOCAL_MODULE_CLASS)))
    ifeq (true, $(LOCAL_IS_HOST_MODULE))
      handle_host_native := true
    endif
  endif
endif

ifeq (true, $(handle_host_native))
#/!\ Host multilib should be handled properly but ignore for now as
#    build is fine without specifying
#    AND there are some issues with mixed default bitness and built bitness
#    eg. prebuilt script makes by default 64b only executable that may require
#    32b executables. In this case, LOCAL_REQUIRED_MODULES fails as it looks for
#    same bitness for binaries.

# Force LOCAL_MODULE_PATH to avoid issues with default bitness/install path for host prebuilts
ifneq (true,$(LOCAL_UNINSTALLABLE_MODULE))
LOCAL_MODULE_RELATIVE_PATH :=
LOCAL_MODULE_PATH := $(my_module_path)
endif # uninstallable
endif # host native

#### target native ####
handle_target_native :=

# Binaries from sources - do not just check on CLASS as for example, an executable could use any class
ifneq (,$(filter executable shared_library static_library, $(_metatarget)))
handle_target_native := true
endif
# Binaries from prebuilt
ifneq (,$(filter prebuilt, $(_metatarget)))
  ifneq (,$(filter STATIC_LIBRARIES SHARED_LIBRARIES EXECUTABLES, $(LOCAL_MODULE_CLASS)))
    ifneq (true, $(LOCAL_IS_HOST_MODULE))
      handle_target_native := true
    endif
  endif
endif

ifeq (true, $(handle_target_native))
  primary_built :=
  secondary_built :=

  # Check standard build path
  ifneq (, $(LOCAL_BUILT_MODULE))
  ifeq (,$(filter $(TARGET_OUT_INTERMEDIATES)/% $($(TARGET_2ND_ARCH_VAR_PREFIX)TARGET_OUT_INTERMEDIATES)/%, $(LOCAL_BUILT_MODULE)))
    $(error [$(LOCAL_MODULE)] with non standard build path [$(LOCAL_BUILT_MODULE)] not supported)
  endif
  endif

  # Look for both bitnesses.
  ifeq ($(my_module_multilib),both)
    primary_built := $(patsubst $($(TARGET_2ND_ARCH_VAR_PREFIX)TARGET_OUT_INTERMEDIATES)/%,$(TARGET_OUT_INTERMEDIATES)/%,$(LOCAL_BUILT_MODULE))
    secondary_built := $(patsubst  $(TARGET_OUT_INTERMEDIATES)/%,$($(TARGET_2ND_ARCH_VAR_PREFIX)TARGET_OUT_INTERMEDIATES)/%,$(LOCAL_BUILT_MODULE))

  # Look for single bitness - LOCAL_BUILT_MODULE will be set only once
  else
    ifneq (,$(filter $(TARGET_OUT_INTERMEDIATES)/%,$(LOCAL_BUILT_MODULE)))
      primary_built := $(LOCAL_BUILT_MODULE)
    else
      secondary_built := $(LOCAL_BUILT_MODULE)
    endif

  endif # multilib=both

  # Gather built files
  ifneq (,$(wildcard $(primary_built)))
    $(call external-gather-files,$(primary_built),$(if $(filter true, $(TARGET_IS_64_BIT)),64,32))
    generate_intel_prebuilts: $(LOCAL_MODULE_PREBUILT_MAKEFILE)
  endif
  ifneq (,$(wildcard $(secondary_built)))
    $(call external-gather-files,$(secondary_built),32)
    generate_intel_prebuilts: $(LOCAL_MODULE_PREBUILT_MAKEFILE)
  endif

gathered := true
endif # target native

#### static java lib ####
# Check for common_javalib.jar as this is where dependency is set from other java modules
ifeq ($(_metatarget),static_java_library)
ifneq (, $(wildcard $(common_javalib.jar)))
$(call external-gather-files)
generate_intel_prebuilts: $(LOCAL_MODULE_PREBUILT_MAKEFILE)
gathered := true
endif
endif

#### default ####
# Collect files if LOCAL_BUILT_MODULE is found
ifneq (true, $(gathered))
ifneq (, $(filter executable shared_library static_library host_executable host_shared_library host_static_library java_library package prebuilt, $(_metatarget)))
ifneq (, $(wildcard $(LOCAL_BUILT_MODULE)))
$(call external-gather-files)
generate_intel_prebuilts: $(LOCAL_MODULE_PREBUILT_MAKEFILE)
endif
endif
endif # gathered == true

#### copy headers ####
# some metatargets also include copy_headers implicitly
ifneq ($(LOCAL_COPY_HEADERS),)
   # Use sort to remove duplicates
   generate_intel_prebuilts: $(LOCAL_MODULE_PREBUILT_MAKEFILE)
   $(my).copyfiles := $(sort $($(my).copyfiles) $(foreach h,$(LOCAL_COPY_HEADERS),$(LOCAL_PATH)/$(h):$(dir $(my))include/$(notdir $(h))))
ifeq ($(LOCAL_COPY_HEADERS_TO),)
   LOCAL_COPY_HEADERS_TO := _none_
endif
   $(my).headers_to := $(sort $($(my).headers_to) $(LOCAL_COPY_HEADERS_TO))
   $(my).headers.$(LOCAL_COPY_HEADERS_TO) := $(sort $($(my).headers.$(LOCAL_COPY_HEADERS_TO)) $(foreach h,$(LOCAL_COPY_HEADERS),include/$(notdir $(h))))
endif

#### custom external ####
ifneq ($(filter custom_external,$(_metatarget)),)
ifneq ($(LOCAL_BUILT_MODULE),)
   $(my).copyfiles := $($(my).copyfiles) $(LOCAL_BUILT_MODULE):$(dir $(my))$(module_type)/$(notdir $(LOCAL_BUILT_MODULE))
endif
   $(my).extramakefile := $($(my).extramakefile) $(LOCAL_PATH)/external_Android.mk
endif

#### phony package ####
# another special case with phony_package, which is a way to define a metapackage that justs
# depends on other packages
ifneq ($(filter phony_package,$(_metatarget)),)
ifneq (, $(wildcard $(LOCAL_BUILT_MODULE)))
   generate_intel_prebuilts: $(LOCAL_MODULE_PREBUILT_MAKEFILE)
   $(my).phony := $($(my).phony) $(LOCAL_MODULE)
   $(my).phony.$(LOCAL_MODULE).LOCAL_REQUIRED_MODULES := $(LOCAL_REQUIRED_MODULES)
endif
endif

###################################### dependencies #########################################
$(LOCAL_MODULE_PREBUILT_MAKEFILE): $(LOCAL_MODULE_MAKEFILE)
$(LOCAL_MODULE_PREBUILT_MAKEFILE): $(call several-files-deps, $($(LOCAL_MODULE_PREBUILT_MAKEFILE).copyfiles))

###################################### cleanups of local variables #########################################

# cleanup local shortcut for LOCAL_MODULE_PREBUILT_MAKEFILE
my :=
endif # is _need_prebuilts
_metatarget :=
_need_prebuilts :=
else # metatarget neq ''
include $(call original-metatarget)
endif
